<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <!-- Step 1: import the element to test -->
    <link rel="import" href="../i18n-number.html">
    <link rel="import" href="bound-i18n-number.html">
  </head>
  <body>

    <test-fixture id="default">
      <template>
        <i18n-number></i18n-number>
      </template>
    </test-fixture>

    <test-fixture id="static">
      <template>
        <i18n-number lang="en" options="{}" offset="1">123456.789</i18n-number>
      </template>
    </test-fixture>

    <test-fixture id="bound">
      <template is="dom-template" id="bound-template">
        <i18n-number lang="en" options="{}" offset="1">{{number}}</i18n-number>
      </template>
    </test-fixture>

    <test-fixture id="bound-and-wrapped">
      <template>
        <bound-i18n-number></bound-i18n-number>
      </template>
    </test-fixture>

    <script>
suite('<i18n-number>', function () {

  suite('default values', function () {
    var el;

    setup(function () {
      el = fixture('default');
    });

    test('default lang property', function () {
      assert.equal(el.lang, 'en', 'default lang is en');
    });

    test('default options property', function () {
      assert.isUndefined(el.options, 'default options is undefined');
    });

    test('default raw property', function () {
      assert.equal(el.raw, '', 'default raw is a null string');
    });

    test('default offset property', function () {
      assert.isNumber(el.offset, 'offset is a number');
      assert.equal(el.offset, 0, 'default offset is 0');
    });

    test('default rawNumber property', function () {
      assert.isUndefined(el.rawNumber, 'rawNumber is undefined when raw is null');
    });

    test('default number property', function () {
      assert.isUndefined(el.number, 'number is undefined when raw is null');
    });

    test('default formatted property', function () {
      assert.isUndefined(el.formatted, 'formatted is undefined when raw is null');
    });
  });

  if (!Number.isNaN) {
    // polyfill Number.isNaN for IE11
    Number.isNaN = function (value) {
      return typeof value === 'number' && isNaN(value);
    };
  }
  var rawValue1 = '123456.789';
  var rawNumber1 = Number(rawValue1);
  var rawValueInvalid = 'ABC';
  var rawNumberInvalid = Number(rawValueInvalid);
  var offset1 = 1;
  var offset2 = 2;
  var offsetInvalid = 'ABCD';
  var number1 = rawNumber1 - offset1;
  var number2 = rawNumber1 - offset2;
  var formatted1_en = '123,455.789';
  var formatted1_fr = '123\u00A0455,789';
  var formatted1_USD = '$123,455.79';
  var formatted1_offset = '123,454.789';
  var suites = [
    { 
      suite: 'static value', 
      fixture: 'static', 
      model: undefined, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      formatted: formatted1_en
    },
    { 
      suite: 'bound value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      formatted: formatted1_en
    },
    { 
      suite: 'change raw value', 
      fixture: 'bound', 
      model: { number: '987654.321' }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      assign: { raw: rawValue1 },
      formatted: formatted1_en
    },
    { 
      suite: 'change lang value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      assign: { lang: 'fr' },
      formatted: formatted1_fr
    },
    { 
      suite: 'change options value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { "style": "currency", "currency": "USD" },
      assign: { options: { 'style': 'currency', 'currency': 'USD' } },
      formatted: formatted1_USD
    },
    { 
      suite: 'change offset value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset2,
      rawNumber: rawNumber1,
      number: number2,
      options: {},
      assign: { offset: offset2 },
      formatted: formatted1_offset
    },
    { 
      suite: 'invalid value', 
      fixture: 'bound', 
      model: { number: rawValueInvalid }, 
      rawValue: rawValueInvalid,
      offset: offset1,
      rawNumber: NaN,
      number: NaN,
      options: {},
      formatted: 'NaN'
    },
    { 
      suite: 'invalid offset value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offsetInvalid,
      rawNumber: rawValue1,
      number: NaN,
      options: {},
      assign: { offset: offsetInvalid },
      formatted: 'NaN'
    }
  ];

  suites.forEach(function (params) {

    suite(params.suite, function () {
      var el;
      var rawValue = params.rawValue;
      var fixtureElement;
      var lang = params.assign && params.assign.lang ? params.assign.lang : 'en';
      var updateModel = function (element, model) {
        for (var p in model) {
          element[p] = model[p];
        }
      }

      setup(function () {
        el = fixture(params.fixture, params.model);
      });

      test('lang property from attribute', function () {
        updateModel(el, params.assign);
        assert.equal(el.lang, lang, 'lang is set');
      });

      test('options property from attribute is set as ' 
          + JSON.stringify(params.options), function () {
        updateModel(el, params.assign);
        assert.deepEqual(el.options, params.options, 'options is set');
      });

      test('textContent is set as ' + rawValue, function () {
        updateModel(el, params.assign);
        assert.equal(Polymer.dom(el).textContent, rawValue, 'textContent is ' + rawValue);
      });

      test('raw property is set as ' + rawValue, function () {
        updateModel(el, params.assign);
        assert.isString(el.raw, 'raw property is a string');
        assert.equal(el.raw, rawValue, 'raw property is set as the raw value');
      });

      test('offset property from attribute is set as ' + params.offset, function () {
        updateModel(el, params.assign);
        if (typeof params.offset === 'number') {
          assert.isNumber(el.offset, 'offset is a number');
        }
        if (Number.isNaN(params.offset)) {
          assert.ok(Number.isNaN(el.offset), 'offset is NaN');
        }
        else {
          assert.equal(el.offset, params.offset, 'offset is ' + params.offset);
        }
      });

      test('rawNumber property is set as ' + params.rawNumber, function () {
        updateModel(el, params.assign);
        assert.isNumber(el.rawNumber, 'rawNumber is a number');
        if (Number.isNaN(params.rawNumber)) {
          assert.ok(Number.isNaN(el.rawNumber), 'rawNumber is NaN');
        }
        else {
          assert.equal(el.rawNumber, params.rawNumber, 'rawNumber is set');
        }
      });

      test('number property is set as ' + params.number, function () {
        updateModel(el, params.assign);
        assert.isNumber(el.number, 'number is a number');
        if (Number.isNaN(params.number)) {
          assert.ok(Number.isNaN(el.number), 'number is NaN');
        }
        else {
          assert.equal(el.number, params.number, 'number is set');
        }
      });

      test('formatted property is set as ' + params.formatted, function () {
        updateModel(el, params.assign);
        assert.isString(el.formatted, 'formatted is a string');
        assert.equal(el.formatted, params.formatted);
      });

      test('renders the formatted number ' + params.formatted, function () {
        updateModel(el, params.assign);
        assert.equal(el.$.number.textContent, params.formatted);
      });

    });
  });

  suite('bound in a local DOM', function () {
    var wrapper;
    var el;

    setup(function () {
      wrapper = fixture('bound-and-wrapped');
    });

    suite('bound and wrapped', function () {
      setup(function () {
        el = wrapper.$.num;
      });

      test('default lang property is en', function () {
        assert.equal(el.lang, 'en', 'default lang is en');
      });

      test('default options property is undefined', function () {
        assert.isUndefined(el.options, 'default options is undefined');
      });

      test('empty raw property', function () {
        assert.isString(el.raw, 'empty raw is a string');
        assert.equal(el.raw, '', 'empty raw is a null string');
      });

      test('default offset property is 0', function () {
        assert.isNumber(el.offset, 'offset is a number');
        assert.equal(el.offset, 0, 'default offset is 0');
      });

      test('default rawNumber property is undefined', function () {
        assert.isUndefined(el.rawNumber, 'rawNumber is undefined when raw is null');
      });

      test('default number property is undefined', function () {
        assert.isUndefined(el.number, 'number is undefined when raw is null');
      });

      test('default formatted property is undefined', function () {
        assert.isUndefined(el.formatted, 'formatted is undefined when raw is null');
      });

      test('renders a null string', function () {
        assert.equal(el.$.number.textContent, '', 'textContent is empty');
      });
    });

    suite('bound value changed', function () {
      setup(function () {
        el = wrapper.$.num;
      });

      test('change bound value to ' + rawNumber1, function (done) {
        el.addEventListener('rendered', function (e) {
          assert.equal(el.$.number.textContent, '123,456.789', 
                      'renders the formatted number');    
          done();
        });
        wrapper.number = rawNumber1;
      });

    });

    suite('non-bound empty textContent changed', function () {
      setup(function () {
        el = wrapper.$.empty;
      });

      test('change empty textContent value to ' + rawNumber1, function (done) {
        el.addEventListener('rendered', function (e) {
          assert.equal(el.$.number.textContent, '123,456.789', 
                      'renders the formatted number');    
          done();
        });
        Polymer.dom(el).textContent = rawNumber1;
      });

    });
  });

});
    </script>

  </body>
</html>
