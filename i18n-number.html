<!--
@license https://github.com/t2ym/i18n-number/blob/master/LICENSE.md
Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
-->

<link rel="import" href="../polymer/polymer.html">

<!--
`<i18n-number>` renders a number in international formats by Intl.NumberFormat 
(http://www.ecma-international.org/ecma-402/1.0/#sec-11.1) object.
If Intl.NumberFormat is unavailable, [Intl.js Polyfill](https://github.com/andyearnshaw/Intl.js) and 
its locale modules are dynamically loaded as a fallback.

    <i18n-number lang="en"
                 options='{ "style": "currency", "currency": "USD" }'
                 offset="1"
                 >123456.78</i18n-number>

This example renders the following number string.

    $123,455.78

@group I18nBehavior
@element i18n-number
@hero hero.svg
@demo demo/index.html
-->
<dom-module id="i18n-number">
  <template>
    <span id="number"></span>
  </template>
  <script>
  (function () {
  var intlLibraryScript;
  var intlLibraryLoadingStatus = 'initializing';

  /**
   * Set up Intl polyfill if required
   */
  function _setupIntlPolyfill () {
    // Polyfill Intl if required
    var intlLibraryUrl = this.resolveUrl('../intl/dist/Intl.min.js');
    if (window.Intl) {
      if (window.IntlPolyfill && window.Intl === window.IntlPolyfill) {
        intlLibraryLoadingStatus = 'loaded';
      }
      else {
        intlLibraryLoadingStatus = 'native';
      }
    }
    else {
      intlLibraryLoadingStatus = 'loading';
      intlLibraryScript = document.createElement('script');
      intlLibraryScript.setAttribute('src', intlLibraryUrl);
      intlLibraryScript.setAttribute('id', 'intl-js-library');
      intlLibraryScript.addEventListener('load', function intlLibraryLoaded (e) {
        intlLibraryLoadingStatus = 'loaded';
        e.target.removeEventListener('load', intlLibraryLoaded);
        return false;
      });
      var s = document.querySelector('script') || document.body;
      s.parentNode.insertBefore(intlLibraryScript, s);
    }
  }

  /**
   * Set up polyfill locale of Intl if required
   *
   * @param {String} locale Target locale to polyfill
   * @param {Function} callback Callback function to handle locale load
   * @return {Boolean} true if supported; false if callback will be called
   */
  function _setupIntlPolyfillLocale (locale, callback) {
    if (!window.IntlPolyfill) {
      switch (intlLibraryLoadingStatus) {
      case 'loading':
        if (intlLibraryScript) {
          var libraryLoadedBindThis = function (e) {
            _setupIntlPolyfillLocale.call(this, locale, callback);
            e.target.removeEventListener('load', libraryLoadedBindThis);
          }.bind(this);
          intlLibraryScript.addEventListener('load', libraryLoadedBindThis);
          return false;
        }
        else {
          console.error('Intl.js is not being loaded');
        }
        break;
      // impossible cases
      case 'initializing':
      case 'loaded':
      case 'native':
      default:
        break;
      }
    }
    else {
      if (intlLibraryLoadingStatus !== 'native') {
        var supported = Intl.NumberFormat.supportedLocalesOf(locale, { localeMatcher: 'lookup' });
        var script;
        var parts;
        var intlScript;
        if (supported.length === 0) {
          // load the locale
          parts = locale.match(/^([a-zA-Z]{1,3})([-_].*)$/);
          if (parts) {
            locale = parts[1].toLowerCase + parts[2].replace(/_/g, '-').toUpperCase();
          }
          else {
            locale = locale.toLowerCase();
          }
          script = document.querySelector('script#intl-js-locale-' + locale);
          if (!script) {
            script = document.createElement('script');
            script.setAttribute('id', 'intl-js-locale-' + locale);
            script.setAttribute('src', this.resolveUrl('../intl/locale-data/jsonp/' + locale + '.js'));
            var intlLocaleLoadedBindThis = function intlLocaleLoaded (e) {
              callback.call(this, locale);
              e.target.removeEventListener('load', intlLocaleLoadedBindThis);
              return false;
            }.bind(this);
            script.addEventListener('load', intlLocaleLoadedBindThis);
            intlScript = document.querySelector('script#intl-js-library') || document.body;
            intlScript.parentNode.insertBefore(script, intlScript.nextSibling);
          }
          else {
            // already loading
            var anotherIntlLocaleLoadedBindThis = function (e) {
              callback.call(this, locale);
              e.target.removeEventListener('load', anotherIntlLocaleLoadedBindThis);
              return false;
            }.bind(this);
            script.addEventListener('load', anotherIntlLocaleLoadedBindThis);
          }
          return false;
        }
      }
    }
    return true;
  }

  Polymer({
    is: 'i18n-number',

    /**
     * Fired whenever the formatted text is rendered.
     *
     * @event rendered
     */
    
    properties: {
      /**
       * The locale for the formatted number.
       * The typical value is bound to `{{effectiveLang}}` when the containing element has
       * `BehaviorsStore.I18nBehavior`.
       */
      lang: {
        type: String,
        value: 'en',
        observer: '_langChanged',
        reflectToAttribute: true
      },

      /**
       * Options object for Intl.NumberFormat 
       * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat)
       */
      options: {
        type: Object,
        observer: '_optionsChanged',
        notify: true
      },

      /**
       * Raw string synchronized with textContent
       */
      raw: {
        type: String,
        observer: '_rawChanged'
      },

      /**
       * Offset for number
       *
       * Note: number = rawNumber - offset 
       */
      offset: {
        type: Number,
        value: 0,
        observer: '_offsetChanged'
      },

      /**
       * Raw number parsed from raw
       */
      rawNumber: {
        type: Number,
        notify: true
      },

      /**
       * Number calculated from rawNumber and offset
       */
      number: {
        type: Number,
        notify: true
      },

      /**
       * Formatted string rendered for UI
       *
       * Note:
       *   - While Intl.js Polyfill locale module is being loaded, the value is set as `undefined` until load completion.
       */
      formatted: {
        type: String,
        notify: true
      }
    },

    observers: [
      '_onOptionsPropertyChanged(options.*)'
    ],

    /**
     * Default locale constant 'en'
     */
    DEFAULT_LANG: 'en',

    /**
     * Start loading Intl polyfill before its registration
     */
    beforeRegister: function () {
      _setupIntlPolyfill.call(this);
    },

    ready: function () {
      this._setupObservers();
      this.raw = this.textNode.data;
    },

    attached: function () {
      this.raw = this.textNode.data;
    },

    /**
     * Set up observers of textContent mutations
     */
    _setupObservers: function () {
      this.textNode = Polymer.dom(this).childNodes[0];
      if (!this.textNode) {
        Polymer.dom(this).appendChild(document.createTextNode(''));
        this.textNode = Polymer.dom(this).childNodes[0];
      }
      this.observer = new MutationObserver(this._textMutated.bind(this));
      this.observer.observe(this.textNode, { characterData: true });
      this.nodeObserver = Polymer.dom(this).observeNodes(function (info) {
        if (info.addedNodes[0] && 
            info.addedNodes[0].nodeType === info.addedNodes[0].TEXT_NODE) {
          this.textNode = info.addedNodes[0];
          this.raw = this.textNode.data;
          //console.log('i18n-number: text node added with ' + this.raw);
          this.observer.observe(this.textNode, { characterData: true });
        }
      }.bind(this));
    },

    /**
     * MutationObserver callback of the child text node to re-render on text mutations.
     *
     * @param {Array} mutations Array of MutationRecord (https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).
     */
    _textMutated: function (mutations) {
      mutations.forEach(function(mutation) {
        switch (mutation.type) {
        case 'characterData':
          //console.log('i18n-number: _textMutated: raw = ' + mutation.target.data);
          if (this.raw !== mutation.target.data) {
            this.raw = mutation.target.data;
          }
          break;
        default:
          break;
        }
      }, this);
    },

    /**
     * Observer of `raw` property to re-render the formatted number.
     *
     * @param {string} raw New raw number string.
     */
    _rawChanged: function (raw) {
      if (this.textNode) {
        if (raw !== this.textNode.data) {
          this.textNode.data = raw;
        }
        //console.log('i18n-number: _rawChanged: raw = ' + raw);
        this._render(this.lang, this.options, raw, this.offset);
      }
    },

    /**
     * Observer of `lang` property to re-render the formatted number.
     *
     * @param {string} lang New locale.
     */
    _langChanged: function (lang) {
      if (!lang) {
        this.lang = this.DEFAULT_LANG;
        lang = this.lang;
      }
      if (this.textNode) {
        //console.log('i18n-number: _langChanged: lang = ' + lang);
        this._render(lang, this.options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `options` property to re-render the formatted number.
     *
     * @param {Object} options New options for Intl.NumberFormat.
     */
    _optionsChanged: function (options) {
      if (this.textNode) {
        //console.log('i18n-number: _optionsChanged: options = ' + JSON.stringify(options));
        this._render(this.lang, options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `options` sub-properties to re-render the formatted number.
     */
    _onOptionsPropertyChanged: function (/* changeRecord */) {
      if (this.textNode) {
        //console.log('_onOptionsPropertyChanged: path = ' + changeRecord.path + ' value = ' + JSON.stringify(changeRecord.value));
        this._render(this.lang, this.options, this.raw, this.offset);
      }
    },

    /**
     * Observer of `offset` property to re-render the formatted number.
     *
     * @param {number} offset New offset.
     */
    _offsetChanged: function (offset) {
      if (this.textNode) {
        //console.log('i18n-number: _offsetChanged: offset = ' + offset);
        this._render(this.lang, this.options, this.raw, offset);
      }
    },

    /**
     * Formats the number
     *
     * @param {string} lang Locale for formatting.
     * @param {Object} options Options for Intl.NumberFormat.
     * @param {number} number Number to format.
     * @return {string} Formatted number string.
     */
    _formatNumber: function (lang, options, number) {
      if (!lang) {
        lang = this.DEFAULT_LANG;
      }
      switch (intlLibraryLoadingStatus) {
      case 'loaded':
      case 'loading':
      default:
        try {
          if (_setupIntlPolyfillLocale.call(this, lang, function (locale) {
            this.render();
          }.bind(this))) {
            return new Intl.NumberFormat(lang, options).format(number);
          }
          else {
            // waiting for callback
            return undefined;
          }
        }
        catch (e) {
          return number.toString();
        }
        break;
      case 'native':
        // native
        try {
          return new Intl.NumberFormat(lang, options).format(number);
        }
        catch (e) {
          return number.toString();
        }
        break;
      }
    },

    /**
     * Renders the formatted number
     *
     * @param {string} lang Locale for formatting.
     * @param {Object} options Options for Intl.NumberFormat.
     * @param {string} raw Raw number string.
     * @param {number} offset Offset for number.
     */
    _render: function (lang, options, raw, offset) {
      // TODO: rendering may be done redundantly on property initializations
      raw = raw.trim();
      if (!raw && !this.formatted) {
        //console.log('i18n-number: skipping _render as raw is null');
        return;
      }
      if (raw) {
        this.rawNumber = Number(raw);
        this.number = this.rawNumber - offset;
        this.formatted = this._formatNumber(lang, options, this.number);
      }
      else {
        this.rawNumber = undefined;
        this.number = undefined;
        this.formatted = '';
      }
      this.$.number.textContent = this.formatted ? this.formatted : '';
      //console.log('i18n-number: _render ' + this.formatted);
      if (typeof this.formatted !== 'undefined') {
        this.fire('rendered');
      }
    },

    /**
     * Renders the formatted number with the current parameters
     *
     * Note: (As of Polymer 1.2.3)
     *   Explicit render() call is needed whenever the observer 
     *   `_onOptionsPropertyChanged(options.*)` is NOT invoked 
     *   after a property of `options` is changed.  An explicit call 
     *   `this.notifyPath('options', this.options, true)` can also 
     *   trigger re-rendering.
     *
     *   If the changed property of `options` is bound in an annotation
     *   like `{{options.currency}}`, the observer `_onOptionsPropertyChanged(options.*)`
     *   is automatically called whenever the property value is changed
     *   and thus no explicit call of `render()` or `notifyPath()` is
     *   required.
     */
    render: function () {
      this._render(this.lang, this.options, this.raw, this.offset);
    }
  });
  })();
  </script>
</dom-module>